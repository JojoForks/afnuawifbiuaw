<!DOCTYPE html>
<html lang="ru">
<head>
	<meta charset="UTF-8">
	<link rel="stylesheet" href="styles.css">
	<script src="https://cdnjs.cloudflare.com/ajax/libs/Turf.js/6.5.0/turf.min.js"></script>
	<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY=" crossorigin="" />
	<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo=" crossorigin=""></script>
	<style>
		/* –°–ø–µ—Ü–∏—Ñ–∏—á–Ω—ã–µ —Å—Ç–∏–ª–∏ –¥–ª—è incompatible_zones_generator */
		body {
			padding: 1.5rem;
		}

		label {
			display: inline-block;
			min-width: 220px;
			margin-bottom: 0.5rem;
		}

		input[type="file"],
		input[type="text"],
		input[type="number"] {
			width: 100%;
			max-width: 400px;
			margin-bottom: 1rem;
		}

		button.small {
			padding: 2px 8px;
			margin-left: 8px;
			font-size: 0.875rem;
		}

		#map {
			height: 520px;
			border: 1px solid var(--border-color);
			border-radius: var(--radius-lg);
			margin: 1rem 0;
		}

		.progress-container {
			width: 100%;
			max-width: 400px;
			margin: 0 auto;
		}

		.progress-bar {
			width: 100%;
			height: 20px;
			background: var(--bg-secondary);
			border-radius: 10px;
			overflow: hidden;
			margin-bottom: 8px;
		}

		.progress-fill {
			height: 100%;
			background: var(--success-color);
			width: 0%;
			transition: width 0.3s;
		}
	</style>
</head>
<body>
	<div id="fileSelectionPanel" class="group">
		<label>–ó–∞–≥—Ä—É–∑–∏—Ç–µ –∑–æ–Ω—ã –ø–æ —Å—Å—ã–ª–∫–µ/UUID –∏–ª–∏ –≤—ã–±–µ—Ä–∏—Ç–µ —Ñ–∞–π–ª:</label><br><br>
		<input type="text" id="urlInput" placeholder="UUID –∏–ª–∏ —Å—Å—ã–ª–∫–∞ –Ω–∞ –ø–ª–∞–Ω–∏—Ä–æ–≤–∞–Ω–∏–µ"><br>
		<input type="file" id="fileInput" accept=".geojson,.json"><br>
		<div id="fileInfo" style="margin-bottom: 1rem; font-weight: 500;"></div>
		<button id="loadButton" class="btn btn-primary">–ó–∞–≥—Ä—É–∑–∏—Ç—å</button>
	</div>

	<div id="loadingProgress" style="display:none; text-align: center; margin: 2rem 0;">
		<div class="progress-container">
			<div class="progress-bar">
				<div id="loadingProgressBar" class="progress-fill"></div>
			</div>
			<div id="loadingProgressText" style="font-size:0.875rem; font-weight: 500;"></div>
		</div>
	</div>

	<div id="workPanel" style="display:none;">
		<div class="group">
			<label for="distanceInput">–í–≤–µ–¥–∏—Ç–µ –¥–∏—Å—Ç–∞–Ω—Ü–∏—é (–≤ –º–µ—Ç—Ä–∞—Ö):</label>
			<input type="number" id="distanceInput" value="500">
			<button id="setIncompatibleButton" class="btn btn-primary" style="margin-left:12px;">–£—Å—Ç–∞–Ω–æ–≤–∏—Ç—å –Ω–µ—Å–æ–≤–º–µ—Å—Ç–∏–º—ã–µ –∑–æ–Ω—ã</button>
			<button id="loadIncompatibleButton" class="btn btn-secondary" style="margin-left:12px;">–ó–∞–≥—Ä—É–∑–∏—Ç—å –Ω–µ—Å–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç–∏</button>
			<input type="file" id="loadIncompatibleFileInput" accept=".json,.txt" style="display: none;">
			<div id="incompatibleProgress" style="display:none; margin-top:8px;">
				<div class="progress-bar">
					<div id="incompatibleProgressBar" class="progress-fill" style="background: var(--accent-color);"></div>
				</div>
				<div id="incompatibleProgressText" style="text-align:center; margin-top:4px; font-size:0.875rem;"></div>
			</div>
		</div>

		<div id="map" style="margin: 12px 0;"></div>

		<button id="toggleCostSettingsButton" class="btn btn-secondary" style="margin: 1rem 0;">–ü–æ–∫–∞–∑–∞—Ç—å –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ —Å—Ç–æ–∏–º–æ—Å—Ç–∏</button>
		<div id="costSettingsGroup" class="group" style="display: none;">
			<h3>–ì–µ–Ω–µ—Ä–∞—Ü–∏—è —Ñ–æ—Ä–º—É–ª—ã —à—Ç—Ä–∞—Ñ–æ–≤ –∑–∞ –¥–æ–ø –∑–æ–Ω—ã</h3>
			<div style="margin-bottom: 1rem;">
				<label for="costInput">–ë–∞–∑–æ–≤–∞—è —Å—Ç–æ–∏–º–æ—Å—Ç—å:</label><br>
				<input type="number" id="costInput" value="800" min="1" style="width: 200px; margin-bottom: 1rem;"><br>

				<label for="penaltyStartZoneInput">–ó–æ–Ω—ã –¥–ª—è –Ω–∞—á–∞–ª–∞ —à—Ç—Ä–∞—Ñ–∞ (–ø–æ —É–º–æ–ª—á–∞–Ω–∏—é 2):</label><br>
				<input type="number" id="penaltyStartZoneInput" value="1" min="1" style="width: 200px; margin-bottom: 1rem;"><br>

				<label for="coefficientInput">–ö–æ—ç—Ñ—Ñ–∏—Ü–∏–µ–Ω—Ç a (–º–∞–∫—Å: <span id="maxCoeffDisplay">0.166</span>):</label><br>
				<input type="number" id="coefficientInput" value="0.01" step="0.001" min="0.01" style="width: 200px; margin-bottom: 1rem;"><br>

				<label for="zonesForMaxPenaltyInput">–ó–æ–Ω –¥–ª—è –º–∞–∫—Å. —à—Ç—Ä–∞—Ñ–∞:</label><br>
				<input type="number" id="zonesForMaxPenaltyInput" value="6" min="2" style="width: 200px; margin-bottom: 1rem;">
			</div>
			<button id="saveFormulaButton" class="btn btn-primary">–°–æ—Ö—Ä–∞–Ω–∏—Ç—å —Ñ–æ—Ä–º—É–ª—É</button>
			<button id="togglePreviewButton" class="btn btn-secondary" style="margin-left:12px;">–ü–æ–∫–∞–∑–∞—Ç—å/—Å–∫—Ä—ã—Ç—å —Ç–∞–±–ª–∏—Ü—É</button>
			<div id="penaltyPreview" style="margin-top: 1rem; display: none;"></div>
		</div>

		<div class="group">
			<label for="penaltyValueInput">–®—Ç—Ä–∞—Ñ –∑–∞ –Ω–µ—Å–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç—å:</label>
			<input type="number" id="penaltyValueInput" value="1000000000" min="1" style="width: 200px; margin-bottom: 1rem;"><br>
			<button id="savePresetButton" class="btn btn-success">üíæ –°–∫–∞—á–∞—Ç—å –ø—Ä–µ—Å–µ—Ç</button>
			<button id="savePlanningButton" class="btn btn-success" style="margin-left:12px; display:none;">üíæ –°–∫–∞—á–∞—Ç—å –ø–ª–∞–Ω–∏—Ä–æ–≤–∞–Ω–∏–µ</button>
			<button id="saveCostFormulaButton" class="btn btn-success" style="margin-left:12px;">üíæ –°–∫–∞—á–∞—Ç—å cost —Ñ–æ—Ä–º—É–ª—É</button>
			<button id="selectAnotherFileButton" class="btn btn-secondary" style="margin-left:12px;">–í—ã–±—Ä–∞—Ç—å –¥—Ä—É–≥–æ–π —Ñ–∞–π–ª</button>
		</div>
	</div>

	<script>
		let components = [];
		let zoneNameToComponentIndex = new Map();
		let compatibleGroups = [];
		let compatibleGroupsSet = new Set();
		let allZoneNames = [];
		let map, baseLayer, zonesLayerGroup;
		let nameToLeafletLayer = new Map();
		let currentCenter = null;
		let adjacencyGlobal = new Map();
		let selectedNeighborsByZone = new Map();
		let planningData = null;
		let loadedGeoJSON = null;
		let currentFeatures = null;

		function determineFileType(data) {
			if (data && typeof data === 'object') {
				if (data.zones && Array.isArray(data.zones)) {
					return 'planning';
				}
				if (data.features && Array.isArray(data.features)) {
					return 'geojson';
				}
			}
			return 'unknown';
		}

		document.getElementById('fileInput').addEventListener('change', (e) => {
			const file = e.target.files[0];
			const fileInfo = document.getElementById('fileInfo');

			if (file) {
				const reader = new FileReader();
				reader.onload = function(e) {
					try {
						const data = JSON.parse(e.target.result);
						const fileType = determineFileType(data);

						if (fileType === 'planning') {
							planningData = data;
							loadedGeoJSON = null;
							const zoneCount = data.zones ? data.zones.length : 0;
							fileInfo.textContent = `–í—ã–±—Ä–∞–Ω —Ñ–∞–π–ª –ø–ª–∞–Ω–∏—Ä–æ–≤–∞–Ω–∏—è —Å ${zoneCount} –∑–æ–Ω(–∞–º–∏)`;
							fileInfo.style.color = '#28a745';
						} else if (fileType === 'geojson') {
							loadedGeoJSON = data;
							planningData = null;
							const zoneCount = data.features ? data.features.length : 0;
							fileInfo.textContent = `–í—ã–±—Ä–∞–Ω —Ñ–∞–π–ª GeoJSON —Å ${zoneCount} –∑–æ–Ω(–∞–º–∏)`;
							fileInfo.style.color = '#007bff';
						} else {
							fileInfo.textContent = '–ù–µ–ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ–º—ã–π —Ñ–æ—Ä–º–∞—Ç —Ñ–∞–π–ª–∞';
							fileInfo.style.color = '#dc3545';
							planningData = null;
							loadedGeoJSON = null;
						}
					} catch (error) {
						fileInfo.textContent = '–û—à–∏–±–∫–∞ –ø—Ä–∏ —á—Ç–µ–Ω–∏–∏ —Ñ–∞–π–ª–∞: ' + error.message;
						fileInfo.style.color = '#dc3545';
						planningData = null;
						loadedGeoJSON = null;
					}
				};
				reader.readAsText(file);
			} else {
				fileInfo.textContent = '';
				planningData = null;
				loadedGeoJSON = null;
			}
		});

		document.getElementById('loadButton').addEventListener('click', async () => {
			const urlInput = document.getElementById('urlInput').value.trim();
			const progressDiv = document.getElementById('loadingProgress');
			const progressBar = document.getElementById('loadingProgressBar');
			const progressText = document.getElementById('loadingProgressText');

			// –ü—Ä–∏–æ—Ä–∏—Ç–µ—Ç: URL > —Ñ–∞–π–ª
			if (urlInput) {
				const uuidMatch = urlInput.match(/([a-f0-9]+-[a-f0-9]+-[a-f0-9]+-[a-f0-9]+)/i);
				if (!uuidMatch) {
					return alert('–ù–µ —É–¥–∞–ª–æ—Å—å –Ω–∞–π—Ç–∏ UUID');
				}

				const uuid = uuidMatch[0];
				const apiUrl = `https://routeq.gens.codes/request/${uuid}`;

				document.getElementById('fileSelectionPanel').style.display = 'none';
				progressDiv.style.display = 'block';
				progressText.textContent = `–ó–∞–≥—Ä—É–∑–∫–∞ –¥–∞–Ω–Ω—ã—Ö: ${uuid}...`;

				try {
					const response = await fetch(apiUrl);
					if (!response.ok) throw new Error(`–û—à–∏–±–∫–∞: ${response.status}`);
					const data = await response.json();
					
					const fileType = determineFileType(data);
					if (fileType === 'planning') {
						planningData = data;
						loadedGeoJSON = null;
					} else if (fileType === 'geojson') {
						loadedGeoJSON = data;
						planningData = null;
					} else {
						throw new Error('–ù–µ–ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ–º—ã–π —Ñ–æ—Ä–º–∞—Ç –¥–∞–Ω–Ω—ã—Ö');
					}

					await initializeMapOnly();
					document.getElementById('workPanel').style.display = 'block';
					await new Promise(resolve => setTimeout(resolve, 50));
					if (map) map.invalidateSize();

					if (planningData) {
						progressText.textContent = '–û–±—Ä–∞–±–æ—Ç–∫–∞ –ø–ª–∞–Ω–∏—Ä–æ–≤–∞–Ω–∏—è...';
						await processPlanningData();
						document.getElementById('savePlanningButton').style.display = 'inline-block';
					} else if (loadedGeoJSON) {
						progressText.textContent = '–ó–∞–≥—Ä—É–∑–∫–∞ –∑–æ–Ω...';
						await processGeoJSON(loadedGeoJSON);
						document.getElementById('savePlanningButton').style.display = 'none';
					}
				} catch (err) {
					console.error(err);
					alert(`–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏: ${err.message}`);
					document.getElementById('fileSelectionPanel').style.display = 'block';
					progressDiv.style.display = 'none';
				}
				return;
			}

			// –ó–∞–≥—Ä—É–∑–∫–∞ –∏–∑ —Ñ–∞–π–ª–∞
			if (!planningData && !loadedGeoJSON) {
				alert('–í–≤–µ–¥–∏—Ç–µ —Å—Å—ã–ª–∫—É/UUID –∏–ª–∏ –≤—ã–±–µ—Ä–∏—Ç–µ —Ñ–∞–π–ª.');
				return;
			}

			document.getElementById('fileSelectionPanel').style.display = 'none';
			progressDiv.style.display = 'block';
			progressText.textContent = '–ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –∫–∞—Ä—Ç—ã...';

			await initializeMapOnly();
			document.getElementById('workPanel').style.display = 'block';
			await new Promise(resolve => setTimeout(resolve, 50));
			if (map) map.invalidateSize();

			if (planningData) {
				progressText.textContent = '–û–±—Ä–∞–±–æ—Ç–∫–∞ —Ñ–∞–π–ª–∞ –ø–ª–∞–Ω–∏—Ä–æ–≤–∞–Ω–∏—è...';
				await processPlanningData();
				document.getElementById('savePlanningButton').style.display = 'inline-block';
			} else if (loadedGeoJSON) {
				progressText.textContent = '–ó–∞–≥—Ä—É–∑–∫–∞ –∑–æ–Ω –Ω–∞ –∫–∞—Ä—Ç—É...';
				await processGeoJSON(loadedGeoJSON);
				document.getElementById('savePlanningButton').style.display = 'none';
			}
		});

		document.getElementById('setIncompatibleButton').addEventListener('click', async () => {
			const radiusInput = document.getElementById('distanceInput').value;
			const radius = parseFloat(radiusInput) || 500;

			if (!currentFeatures || currentFeatures.length === 0) {
				alert('–ù–µ—Ç –∑–∞–≥—Ä—É–∂–µ–Ω–Ω—ã—Ö –∑–æ–Ω –¥–ª—è –ø–µ—Ä–µ—Å—á–µ—Ç–∞.');
				return;
			}

			const button = document.getElementById('setIncompatibleButton');
			const progressDiv = document.getElementById('incompatibleProgress');
			const progressBar = document.getElementById('incompatibleProgressBar');
			const progressText = document.getElementById('incompatibleProgressText');

			button.disabled = true;
			progressDiv.style.display = 'block';
			progressText.textContent = '–†–∞—Å—á–µ—Ç –Ω–µ—Å–æ–≤–º–µ—Å—Ç–∏–º—ã—Ö –∑–æ–Ω...';

			const edges = new Map();
			for (let name of allZoneNames) edges.set(name, new Set());

			const featureCoords = currentFeatures.map(feature => turf.coordAll(feature));
			const totalPairs = (currentFeatures.length * (currentFeatures.length - 1)) / 2;
			let processedPairs = 0;

			for (let i = 0; i < currentFeatures.length; i++) {
				const feature1 = currentFeatures[i];
				const name1 = feature1.properties.description;
				for (let j = i + 1; j < currentFeatures.length; j++) {
					const feature2 = currentFeatures[j];
					const name2 = feature2.properties.description;

					const intersects = turf.booleanIntersects(feature1, feature2);

					let minDistance = Infinity;
					const coords1 = featureCoords[i];
					const coords2 = featureCoords[j];
					for (let p1 of coords1) {
						for (let p2 of coords2) {
							const point1 = turf.point(p1);
							const point2 = turf.point(p2);
							const distance = turf.distance(point1, point2, { units: 'meters' });
							if (distance < minDistance) minDistance = distance;
							if (minDistance <= radius) break;
						}
						if (minDistance <= radius) break;
					}

					if (intersects || minDistance <= radius) {
						edges.get(name1).add(name2);
						edges.get(name2).add(name1);
					}

					processedPairs++;
					const progress = (processedPairs / totalPairs) * 100;
					progressBar.style.width = progress + '%';
					progressText.textContent = `–û–±—Ä–∞–±–æ—Ç–∞–Ω–æ ${processedPairs} –∏–∑ ${totalPairs} –ø–∞—Ä –∑–æ–Ω`;

					if (processedPairs % 100 === 0) {
						await new Promise(resolve => setTimeout(resolve, 10));
					}
				}
			}

		selectedNeighborsByZone = edges;
		adjacencyGlobal = new Map();
		allZoneNames.forEach(a => adjacencyGlobal.set(a, new Set()));
		for (let i = 0; i < allZoneNames.length; i++) {
			for (let j = i + 1; j < allZoneNames.length; j++) {
				const a = allZoneNames[i];
				const b = allZoneNames[j];
				const compatible = selectedNeighborsByZone.get(a)?.has(b) || selectedNeighborsByZone.get(b)?.has(a);
				if (!compatible) {
					adjacencyGlobal.get(a).add(b);
					adjacencyGlobal.get(b).add(a);
				}
			}
		}

		rebuildComponentsFromSelections();
		clearAllStyles();

		progressDiv.style.display = 'none';
		button.disabled = false;
		
		const compatibleCount = Array.from(selectedNeighborsByZone.values()).reduce((sum, set) => sum + set.size, 0) / 2;
		const incompatibleCount = Array.from(adjacencyGlobal.values()).reduce((sum, set) => sum + set.size, 0) / 2;
		alert(`–ó–æ–Ω—ã –æ–±—Ä–∞–±–æ—Ç–∞–Ω—ã. –ù–∞–π–¥–µ–Ω–æ ${compatibleCount} —Å–æ–≤–º–µ—Å—Ç–∏–º—ã—Ö –ø–∞—Ä (–±–ª–∏–∑–∫–∏–µ/–ø–µ—Ä–µ—Å–µ–∫–∞—é—â–∏–µ—Å—è) –∏ ${incompatibleCount} –Ω–µ—Å–æ–≤–º–µ—Å—Ç–∏–º—ã—Ö –ø–∞—Ä.`);
		});

		document.getElementById('loadIncompatibleButton').addEventListener('click', () => {
			document.getElementById('loadIncompatibleFileInput').click();
		});

		document.getElementById('loadIncompatibleFileInput').addEventListener('change', (e) => {
			const file = e.target.files[0];
			if (!file) return;

			const reader = new FileReader();
			reader.onload = function(e) {
				try {
					const data = JSON.parse(e.target.result);
					let incompatibleZones = [];
					let compatibleZones = [];

					if (data && data.options && Array.isArray(data.options.incompatible_zones)) {
						incompatibleZones = data.options.incompatible_zones;
						if (Array.isArray(data.options.compatible_zones)) compatibleZones = data.options.compatible_zones;
					} else if (data && Array.isArray(data.incompatible_zones)) {
						incompatibleZones = data.incompatible_zones;
						if (Array.isArray(data.compatible_zones)) compatibleZones = data.compatible_zones;
					} else if (data && typeof data.cost === 'string') {
						const pairs = parseCostFormula(data.cost);
						if (pairs.length > 0) {
							incompatibleZones = pairs;
						} else {
							alert('–ù–µ —É–¥–∞–ª–æ—Å—å —Ä–∞—Å–ø–∞—Ä—Å–∏—Ç—å —Ñ–æ—Ä–º—É–ª—É cost.');
							return;
						}
					} else {
						alert('–ù–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç —Ñ–∞–π–ª–∞. –û–∂–∏–¥–∞–µ—Ç—Å—è –º–∞—Å—Å–∏–≤ incompatible_zones –∏–ª–∏ —Ñ–æ—Ä–º—É–ª–∞ cost.');
						return;
					}

					selectedNeighborsByZone = new Map();
					allZoneNames.forEach(name => {
						selectedNeighborsByZone.set(name, new Set());
					});

					adjacencyGlobal = new Map();
					allZoneNames.forEach(name => adjacencyGlobal.set(name, new Set()));
					for (let group of incompatibleZones) {
						if (!Array.isArray(group)) continue;
						if (group.length === 2) {
							const a = String(group[0]);
							const b = String(group[1]);
							if (a && b && a !== b && adjacencyGlobal.has(a) && adjacencyGlobal.has(b)) {
								adjacencyGlobal.get(a).add(b);
								adjacencyGlobal.get(b).add(a);
							}
						} else if (group.length > 2) {
							for (let i = 0; i < group.length; i++) {
								for (let j = i + 1; j < group.length; j++) {
									const a = String(group[i]);
									const b = String(group[j]);
									if (a && b && a !== b && adjacencyGlobal.has(a) && adjacencyGlobal.has(b)) {
										adjacencyGlobal.get(a).add(b);
										adjacencyGlobal.get(b).add(a);
									}
								}
							}
						}
					}

					if (compatibleZones && compatibleZones.length > 0) {
						applyCompatibleFromPlanning(compatibleZones);
					} else {
						for (let i = 0; i < allZoneNames.length; i++) {
							for (let j = i + 1; j < allZoneNames.length; j++) {
								const a = allZoneNames[i];
								const b = allZoneNames[j];
								const incompatible = adjacencyGlobal.get(a)?.has(b) || adjacencyGlobal.get(b)?.has(a);
								if (!incompatible) {
									selectedNeighborsByZone.get(a).add(b);
									selectedNeighborsByZone.get(b).add(a);
								}
							}
						}
					}

					rebuildComponentsFromSelections();

					alert(`–ó–∞–≥—Ä—É–∂–µ–Ω—ã –Ω–µ—Å–æ–≤–º–µ—Å—Ç–∏–º—ã–µ –∑–æ–Ω—ã –∏–∑ —Ñ–∞–π–ª–∞`);

				} catch (error) {
					alert('–û—à–∏–±–∫–∞ –ø—Ä–∏ —á—Ç–µ–Ω–∏–∏ —Ñ–∞–π–ª–∞: ' + error.message);
				}
			};
			reader.readAsText(file);

					e.target.value = '';
		});

		document.getElementById('saveFormulaButton').addEventListener('click', () => {
			const zonesList = allZoneNames.slice().sort();
			const zoneExprs = zonesList.map(z => `has_location(in_zone('${z}'))`).join(' + ');
			const penaltyStartZone = parseFloat(document.getElementById('penaltyStartZoneInput').value) || 2;
			const zonesForMaxPenalty = parseFloat(document.getElementById('zonesForMaxPenaltyInput').value) || 6;

			const a = parseFloat(document.getElementById('coefficientInput').value) || 0.166;
			const mTerm = `max(( ${zoneExprs} ) - 1, 0)`;
			const cost = parseFloat(document.getElementById('costInput').value) || 0;
			
			const limitedMTerm = `min(${mTerm}, ${zonesForMaxPenalty - 1})`;
			const effectiveZones = `max((${limitedMTerm} - ${penaltyStartZone - 1}), 0)`;
			const costExpr = `${cost} * ((1 - ${a}) / ${a}) * max((1 / (1 - ${a} * ${effectiveZones}) - 1), 0)`;

			downloadJsonFile({ cost: costExpr }, 'cost_formula.json');
		});

	document.getElementById('savePresetButton').addEventListener('click', () => {
		rebuildComponentsFromSelections();
		const incompatibleExport = buildIncompatibleExport();
		const compatibleExport = buildCompatibleExport();
		const result = {
			incompatible_zones: incompatibleExport,
			compatible_zones: compatibleExport
		};
		downloadJsonFile(result, 'options_preset.json');
	});

	document.getElementById('savePlanningButton').addEventListener('click', () => {
		if (!planningData) return alert('–ù–µ—Ç –¥–∞–Ω–Ω—ã—Ö –ø–ª–∞–Ω–∏—Ä–æ–≤–∞–Ω–∏—è');
		rebuildComponentsFromSelections();
		const incompatibleExport = buildIncompatibleExport();
		const compatibleExport = buildCompatibleExport();
		const updatedPlanning = JSON.parse(JSON.stringify(planningData));
		if (!updatedPlanning.options) {
			updatedPlanning.options = {};
		}
		updatedPlanning.options.incompatible_zones = incompatibleExport;
		updatedPlanning.options.compatible_zones = compatibleExport;
		downloadJsonFile(updatedPlanning, 'planning.json');
	});

	document.getElementById('saveCostFormulaButton').addEventListener('click', () => {
		rebuildComponentsFromSelections();
		const incompatibleExport = buildIncompatibleExport();
		const compatibleExport = buildCompatibleExport();
		const penalty = parseFloat(document.getElementById('penaltyValueInput').value) || 1000000000;
		
		const formula = buildIncompatibilityCostFormula(incompatibleExport, compatibleExport, penalty);
		downloadJsonFile({ cost: formula }, 'incompatibility_cost_formula.json');
	});

		document.getElementById('selectAnotherFileButton').addEventListener('click', () => {
			resetToFileSelection();
		});

		function resetToFileSelection() {
			document.getElementById('workPanel').style.display = 'none';
			document.getElementById('loadingProgress').style.display = 'none';

			document.getElementById('fileSelectionPanel').style.display = 'block';

			components = [];
			zoneNameToComponentIndex = new Map();
			compatibleGroups = [];
			compatibleGroupsSet = new Set();
			allZoneNames = [];
			adjacencyGlobal = new Map();
			selectedNeighborsByZone = new Map();
			planningData = null;
			loadedGeoJSON = null;
			currentFeatures = null;

			if (map) {
				map.remove();
				map = null;
			}

			document.getElementById('fileInfo').textContent = '';

			document.getElementById('loadingProgressBar').style.width = '0%';
			document.getElementById('incompatibleProgressBar').style.width = '0%';

			document.getElementById('fileInput').value = '';
			document.getElementById('urlInput').value = '';
			document.getElementById('savePlanningButton').style.display = 'none';
		}

		function extractCompatibleGroupsFromPlanning() {
			if (!planningData || !planningData.options || !planningData.options.compatible_zones) {
				return null;
			}
			return planningData.options.compatible_zones;
		}

		function extractIncompatibleGroupsFromPlanning() {
			if (!planningData || !planningData.options || !planningData.options.incompatible_zones) {
				return null;
			}
			return planningData.options.incompatible_zones;
		}

	function buildIncompatibleExport() {
		const zones = allZoneNames.slice().sort();
		return [zones];
	}

	function buildCompatibleExport() {
		const result = [];
		const usedPairs = new Set();
		const zones = allZoneNames.slice().sort();
		
		const pairKey = (a, b) => {
			const x = a < b ? a : b;
			const y = a < b ? b : a;
			return x + '|' + y;
		};
		
		const hasEdge = (a, b) => {
			const setA = selectedNeighborsByZone.get(a);
			if (!setA) return false;
			return setA.has(b);
		};

		for (let i = 0; i < zones.length; i++) {
			for (let j = i + 1; j < zones.length; j++) {
				for (let k = j + 1; k < zones.length; k++) {
					const a = zones[i], b = zones[j], c = zones[k];
					if (hasEdge(a, b) && hasEdge(a, c) && hasEdge(b, c)) {
						const k1 = pairKey(a, b), k2 = pairKey(a, c), k3 = pairKey(b, c);
						if (!usedPairs.has(k1) && !usedPairs.has(k2) && !usedPairs.has(k3)) {
							result.push([a, b, c]);
							usedPairs.add(k1); usedPairs.add(k2); usedPairs.add(k3);
						}
					}
				}
			}
		}

		for (let i = 0; i < zones.length; i++) {
			for (let j = i + 1; j < zones.length; j++) {
				const a = zones[i];
				const b = zones[j];
				const key = pairKey(a, b);
				if (!usedPairs.has(key) && hasEdge(a, b)) {
					result.push([a, b]);
					usedPairs.add(key);
				}
			}
		}

		return result;
	}

	function parseCostFormula(formula) {
		const pairs = [];
		const regex = /has_(?:order|location)\(in_zone\('([^']+)'\)\)\s*&\s*has_(?:order|location)\(in_zone\('([^']+)'\)\)/g;
		let match;
		while ((match = regex.exec(formula)) !== null) {
			const a = match[1].replace(/\\'/g, "'");
			const b = match[2].replace(/\\'/g, "'");
			if (a && b && a !== b) {
				pairs.push([a, b]);
			}
		}
		return pairs;
	}

	function buildIncompatibilityCostFormula(incompatibleZones, compatibleZones, penalty) {
		const pairKey = (a, b) => {
			const x = a < b ? a : b;
			const y = a < b ? b : a;
			return x + '|' + y;
		};

		const incompPairs = new Set();
		for (const group of incompatibleZones) {
			if (!Array.isArray(group)) continue;
			const names = [...new Set(group.map(s => String(s)))];
			for (let i = 0; i < names.length; i++) {
				for (let j = i + 1; j < names.length; j++) {
					incompPairs.add(pairKey(names[i], names[j]));
				}
			}
		}

		const compPairs = new Set();
		for (const group of compatibleZones) {
			if (!Array.isArray(group)) continue;
			const names = [...new Set(group.map(s => String(s)))];
			for (let i = 0; i < names.length; i++) {
				for (let j = i + 1; j < names.length; j++) {
					compPairs.add(pairKey(names[i], names[j]));
				}
			}
		}

		const conflicts = [];
		for (const pair of incompPairs) {
			if (!compPairs.has(pair)) {
				conflicts.push(pair);
			}
		}
		conflicts.sort();

		if (conflicts.length === 0) {
			return "0";
		}

		const exprs = conflicts.map(pair => {
			const [a, b] = pair.split('|');
			const aEsc = a.replace(/'/g, "\\'");
			const bEsc = b.replace(/'/g, "\\'");
			return `(has_order(in_zone('${aEsc}')) & has_order(in_zone('${bEsc}')))`;
		});

		return `(${exprs.join(' | ')}) * ${penalty}`;
	}

		function applyCompatibleFromPlanning(groups) {
			let applied = 0;
			groups.forEach(group => {
				if (!Array.isArray(group) || group.length < 2) return;
				if (group.length === 2) {
					const a = String(group[0]);
					const b = String(group[1]);
					if (a && b && a !== b && selectedNeighborsByZone.has(a) && selectedNeighborsByZone.has(b)) {
						selectedNeighborsByZone.get(a).add(b);
						selectedNeighborsByZone.get(b).add(a);
						applied++;
					}
				} else if (group.length === 3) {
					const a = String(group[0]);
					const b = String(group[1]);
					const c = String(group[2]);
					const triples = [[a,b],[a,c],[b,c]];
					triples.forEach(([x,y]) => {
						if (x && y && x !== y && selectedNeighborsByZone.has(x) && selectedNeighborsByZone.has(y)) {
							selectedNeighborsByZone.get(x).add(y);
							selectedNeighborsByZone.get(y).add(x);
							applied++;
						}
					});
				} else {
					const center = String(group[0]);
					for (let i = 1; i < group.length; i++) {
						const other = String(group[i]);
						if (center && other && center !== other && selectedNeighborsByZone.has(center) && selectedNeighborsByZone.has(other)) {
							selectedNeighborsByZone.get(center).add(other);
							selectedNeighborsByZone.get(other).add(center);
							applied++;
						}
					}
				}
			});
			return applied;
		}

		async function processPlanningData() {
			if (!planningData || !planningData.zones) {
				alert('–§–∞–π–ª –ø–ª–∞–Ω–∏—Ä–æ–≤–∞–Ω–∏—è –Ω–µ —Å–æ–¥–µ—Ä–∂–∏—Ç –∑–æ–Ω –¥–ª—è –æ–±—Ä–∞–±–æ—Ç–∫–∏.');
				return;
			}

			const geojsonFeatures = planningData.zones.map(zone => ({
				type: 'Feature',
				geometry: zone.geometry,
				properties: {
					description: zone.id
				}
			}));

			const geojson = {
				type: 'FeatureCollection',
				features: geojsonFeatures
			};

			await processGeoJSON(geojson);
		}

		async function processGeoJSON(geojson) {
			components = [];
			zoneNameToComponentIndex = new Map();
			compatibleGroups = [];
			compatibleGroupsSet = new Set();
			allZoneNames = [];
			adjacencyGlobal = new Map();
			selectedNeighborsByZone = new Map();

			const planningCompatibleGroups = extractCompatibleGroupsFromPlanning();
			const planningIncompatibleGroups = extractIncompatibleGroupsFromPlanning();

			const features = normalizeFeatures(geojson);
			if (!features || features.length === 0) {
				alert('–§–∞–π–ª –Ω–µ —Å–æ–¥–µ—Ä–∂–∏—Ç –∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã—Ö –≥–µ–æ–∑–æ–Ω –¥–ª—è –æ–±—Ä–∞–±–æ—Ç–∫–∏.');
				return;
			}

			currentFeatures = features;
			for (let feature of features) {
				if (!feature.properties || !feature.properties.description) {
					return;
				}
			}

			allZoneNames = features.map(f => f.properties.description);

			allZoneNames.forEach(name => {
				selectedNeighborsByZone.set(name, new Set());
				adjacencyGlobal.set(name, new Set());
			});

			if (planningIncompatibleGroups && planningIncompatibleGroups.length > 0) {
				for (let group of planningIncompatibleGroups) {
					if (!Array.isArray(group)) continue;
					for (let i = 0; i < group.length; i++) {
						for (let j = i + 1; j < group.length; j++) {
							const a = String(group[i]).trim();
							const b = String(group[j]).trim();
							if (a && b && a !== b && adjacencyGlobal.has(a) && adjacencyGlobal.has(b)) {
								adjacencyGlobal.get(a).add(b);
								adjacencyGlobal.get(b).add(a);
							}
						}
					}
				}
			}

			if (planningCompatibleGroups && planningCompatibleGroups.length > 0) {
				applyCompatibleFromPlanning(planningCompatibleGroups);
			}

			rebuildComponentsFromSelections();
			await loadZonesToMap(features);

			document.getElementById('loadingProgress').style.display = 'none';
		}

		function renderGroupsUI() { }

		async function initializeMapOnly() {
			const mapDiv = document.getElementById('map');
			mapDiv.style.display = 'block';

			if (!map) {
				map = L.map('map').setView([55.7558, 37.6173], 10);
				baseLayer = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
					maxZoom: 19,
					attribution: '&copy; OpenStreetMap contributors'
				}).addTo(map);
				zonesLayerGroup = L.layerGroup().addTo(map);

				await new Promise((resolve) => {
					map.on('load', () => resolve());
					setTimeout(resolve, 2000);
				});
			}
		}

		async function loadZonesToMap(features) {
			zonesLayerGroup.clearLayers();
			nameToLeafletLayer = new Map();

			const bounds = [];
			const progressBar = document.getElementById('loadingProgressBar');
			const progressText = document.getElementById('loadingProgressText');

			for (let i = 0; i < features.length; i++) {
				const f = features[i];
				const name = f.properties.description;

				const gj = L.geoJSON(f, {
					style: { color: '#3388ff', weight: 2, fillOpacity: 0.25 }
				}).addTo(zonesLayerGroup);

				gj.on('click', (e) => onLeftClickZone(name, e));
				gj.on('contextmenu', (e) => onRightClickZone(name, e));
				nameToLeafletLayer.set(name, gj);

				try { bounds.push(gj.getBounds()); } catch (e) {}

				const progress = ((i + 1) / features.length) * 100;
				progressBar.style.width = progress + '%';
				progressText.textContent = `–ó–∞–≥—Ä—É–∂–µ–Ω–æ ${i + 1} –∏–∑ ${features.length} –∑–æ–Ω`;

				await new Promise(resolve => setTimeout(resolve, 10));
			}

			if (bounds.length) {
				let union = bounds[0];
				for (let i = 1; i < bounds.length; i++) union = union.extend(bounds[i]);
				map.fitBounds(union.pad(0.1));
			}

			if (map) {
				map.invalidateSize();
			}
		}

		function focusOnZone(name) {
			if (currentCenter === name) {
				clearAllStyles();
				currentCenter = null;
				return;
			}
			currentCenter = name;
			highlightZoneAndNeighbors(name);
		}

		function highlightZoneAndNeighbors(name) {
			clearAllStyles();
			const centerLayer = nameToLeafletLayer.get(name);
			if (centerLayer) {
				centerLayer.setStyle({ color: '#d33', weight: 3, fillOpacity: 0.35 });
			}
			let unionBounds = centerLayer ? centerLayer.getBounds() : null;
			(selectedNeighborsByZone.get(name) || new Set()).forEach(nei => {
				const l = nameToLeafletLayer.get(nei);
				if (l) {
					l.setStyle({ color: '#e600ff', weight: 3, fillOpacity: 0.3 });
					try { unionBounds = unionBounds ? unionBounds.extend(l.getBounds()) : l.getBounds(); } catch (e) {}
				}
			});
			if (unionBounds) {
				try { map.fitBounds(unionBounds.pad(0.2)); } catch (e) {}
			}
		}

		function clearAllStyles() {
			nameToLeafletLayer.forEach(layer => layer.setStyle({ color: '#3388ff', weight: 2, fillOpacity: 0.25 }));
		}

		function toggleCompatibility(a, b) {
			if (!selectedNeighborsByZone.has(a)) selectedNeighborsByZone.set(a, new Set());
			if (!selectedNeighborsByZone.has(b)) selectedNeighborsByZone.set(b, new Set());
			const setA = selectedNeighborsByZone.get(a);
			const setB = selectedNeighborsByZone.get(b);
			if (setA.has(b)) {
				setA.delete(b);
				setB.delete(a);
			} else {
				setA.add(b);
				setB.add(a);
			}
		}

		function onLeftClickZone(name, e) {
			const withModifier = (e && (e.originalEvent ? (e.originalEvent.shiftKey || e.originalEvent.ctrlKey || e.originalEvent.altKey || e.originalEvent.metaKey) : (e.shiftKey || e.ctrlKey || e.altKey || e.metaKey)));
			if (withModifier && currentCenter && currentCenter !== name) {
				toggleCompatibility(currentCenter, name);
				highlightZoneAndNeighbors(currentCenter);
				rebuildComponentsFromSelections();
				renderGroupsUI();
				return;
			}
			focusOnZone(name);
		}

		function onRightClickZone(name, e) {
			if (e && e.originalEvent && e.originalEvent.preventDefault) e.originalEvent.preventDefault();
			if (e && e.originalEvent && e.originalEvent.stopPropagation) e.originalEvent.stopPropagation();
			if (!currentCenter) return;
			if (currentCenter === name) return;
			const a = currentCenter;
			const b = name;
			toggleCompatibility(a, b);
			highlightZoneAndNeighbors(a);
			rebuildComponentsFromSelections();
			renderGroupsUI();
		}

		function rebuildComponentsFromSelections() {
			const processed = new Set();
			components = [];

			for (const name of allZoneNames.slice().sort()) {
				if (processed.has(name)) continue;

				const neighbors = Array.from(selectedNeighborsByZone.get(name) || []).sort();
				if (neighbors.length > 0) {
					const group = [name, ...neighbors];
					components.push(group);

					group.forEach(zone => processed.add(zone));
				}
			}
		}


		function normalizeFeatures(geojson) {
			if (geojson.features && Array.isArray(geojson.features)) {
				return geojson.features;
			} else if (geojson.zones && Array.isArray(geojson.zones)) {
				return geojson.zones.map(zone => {
					return {
						type: 'Feature',
						geometry: zone.geometry,
						properties: {
							description: zone.id
						}
					};
				});
			} else {
				alert('–ù–µ–ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ–º—ã–π —Ñ–æ—Ä–º–∞—Ç —Ñ–∞–π–ª–∞.');
				return [];
			}
		}

		function downloadJsonFile(data, filename) {
			const dataStr = JSON.stringify(data, null, 2);
			const blob = new Blob([dataStr], { type: "application/json" });
			const url = URL.createObjectURL(blob);
			const a = document.createElement('a');
			a.href = url;
			a.download = filename;
			document.body.appendChild(a);
			a.click();
			document.body.removeChild(a);
			URL.revokeObjectURL(url);
		}

		function calculatePenalty(numZones, cost, penaltyStartZone, maxPenalty, zonesForMaxPenalty) {
			if (numZones < penaltyStartZone) return 0;
			
			if (numZones > zonesForMaxPenalty) {
				return calculatePenalty(zonesForMaxPenalty, cost, penaltyStartZone, maxPenalty, zonesForMaxPenalty);
			}

			const a = parseFloat(document.getElementById('coefficientInput').value) || 0.166;
			const mTermValue = Math.max(0, numZones - 1);
			const inner = Math.max(Math.min(mTermValue, zonesForMaxPenalty) - (penaltyStartZone - 1), 0);
			if (inner <= 0) return 0;
			const penalty = cost * ((1 - a) / a) * (1 / (1 - a * inner) - 1);
			return Math.max(0, penalty);
		}

		function updatePenaltyPreview() {
			const zonesForMaxPenalty = parseFloat(document.getElementById('zonesForMaxPenaltyInput').value) || 6;
			
			const minPenaltyStart = 1;
			const maxPenaltyStart = Math.max(1, zonesForMaxPenalty - 1);
			let penaltyStartZone = parseFloat(document.getElementById('penaltyStartZoneInput').value);
			
			if (!penaltyStartZone || penaltyStartZone < minPenaltyStart || penaltyStartZone > maxPenaltyStart) {
				penaltyStartZone = Math.min(2, maxPenaltyStart);
				document.getElementById('penaltyStartZoneInput').value = penaltyStartZone;
			}
			
			const penaltyPreviewDiv = document.getElementById('penaltyPreview');

			const activeZones = Math.max(1, zonesForMaxPenalty - penaltyStartZone + 1);
			const maxAllowedA = 1 / activeZones;
			
			document.getElementById('maxCoeffDisplay').textContent = maxAllowedA.toFixed(3);
			
			let userA = parseFloat(document.getElementById('coefficientInput').value);
			if (!userA || userA <= 0) {
				userA = Math.min(0.166, maxAllowedA);
			}
			if (userA > maxAllowedA) {
				userA = maxAllowedA;
				document.getElementById('coefficientInput').value = userA.toFixed(3);
			}
			const a = Math.max(0.01, userA);
			
			const actualStart = penaltyStartZone - 1;
			const innerForMax = zonesForMaxPenalty - 2 * actualStart + 2;

			let cost = parseFloat(document.getElementById('costInput').value) || 0;
			
			let maxPenalty = 0;
			if (innerForMax > 0) {
				const multiplier = ((1 - a) / a) * (1 / (1 - a * innerForMax) - 1);
				maxPenalty = cost * multiplier;
			}

			if (cost <= 0) {
				penaltyPreviewDiv.innerHTML = '<p style="color: #dc3545;">–ë–∞–∑–æ–≤–∞—è —Å—Ç–æ–∏–º–æ—Å—Ç—å –¥–æ–ª–∂–Ω–∞ –±—ã—Ç—å –±–æ–ª—å—à–µ 0 –¥–ª—è —Ä–∞—Å—á–µ—Ç–∞ —à—Ç—Ä–∞—Ñ–æ–≤.</p>';
				return;
			}

			let previewHtml = '<h4>–ü—Ä–µ–¥–ø—Ä–æ—Å–º–æ—Ç—Ä —à—Ç—Ä–∞—Ñ–æ–≤:</h4><table style="width:100%; border-collapse: collapse; line-height: 1.2;"><thead><tr><th style="border: 1px solid #ccc; padding: 4px 8px; text-align: left;">–ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –∑–æ–Ω</th><th style="border: 1px solid #ccc; padding: 4px 8px; text-align: left;">–®—Ç—Ä–∞—Ñ</th></tr></thead><tbody>';

			const maxZonesToPreview = zonesForMaxPenalty + 4;
			for (let i = 1; i <= maxZonesToPreview; i++) {
				const penalty = calculatePenalty(i, cost, penaltyStartZone, maxPenalty, zonesForMaxPenalty);
				previewHtml += `<tr><td style="border: 1px solid #ccc; padding: 4px 8px;">${i}</td><td style="border: 1px solid #ccc; padding: 4px 8px;">${penalty.toFixed(2)}</td></tr>`;
			}

			previewHtml += '</tbody></table>';
			penaltyPreviewDiv.innerHTML = previewHtml;
		}

		document.addEventListener('DOMContentLoaded', updatePenaltyPreview);
		document.getElementById('costInput').addEventListener('input', updatePenaltyPreview);
		document.getElementById('penaltyStartZoneInput').addEventListener('change', updatePenaltyPreview);
		document.getElementById('coefficientInput').addEventListener('input', updatePenaltyPreview);
		document.getElementById('zonesForMaxPenaltyInput').addEventListener('change', updatePenaltyPreview);
		
		document.getElementById('penaltyStartZoneInput').addEventListener('input', function() {
			const value = parseInt(this.value);
			const maxZones = parseInt(document.getElementById('zonesForMaxPenaltyInput').value) || 6;
			if (value < 1) this.value = 1;
			if (value >= maxZones) this.value = Math.max(1, maxZones - 1);
		});
		
		document.getElementById('zonesForMaxPenaltyInput').addEventListener('input', function() {
			const value = parseInt(this.value);
			const startZone = parseInt(document.getElementById('penaltyStartZoneInput').value) || 1;
			if (value < 2) this.value = 2;
			if (value <= startZone) {
				document.getElementById('penaltyStartZoneInput').value = Math.max(1, value - 1);
			}
		});
		
		document.getElementById('coefficientInput').addEventListener('input', function() {
			const value = parseFloat(this.value);
			if (value < 0.01) this.value = 0.01;
		});
		
		document.getElementById('costInput').addEventListener('input', function() {
			const value = parseFloat(this.value);
			if (value < 1) this.value = 1;
		});
		
		document.getElementById('toggleCostSettingsButton').addEventListener('click', () => {
			const settingsGroup = document.getElementById('costSettingsGroup');
			const button = document.getElementById('toggleCostSettingsButton');
			if (settingsGroup.style.display === 'none') {
				settingsGroup.style.display = 'block';
				button.textContent = '–°–∫—Ä—ã—Ç—å –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ —Å—Ç–æ–∏–º–æ—Å—Ç–∏';
			} else {
				settingsGroup.style.display = 'none';
				button.textContent = '–ü–æ–∫–∞–∑–∞—Ç—å –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ —Å—Ç–æ–∏–º–æ—Å—Ç–∏';
			}
		});

		document.getElementById('togglePreviewButton').addEventListener('click', () => {
			const previewDiv = document.getElementById('penaltyPreview');
			if (previewDiv.style.display === 'none') {
				previewDiv.style.display = 'block';
				updatePenaltyPreview();
			} else {
				previewDiv.style.display = 'none';
			}
		});
	</script>
	<script>
function applyStreamlitStyles() {
    const isDark = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;

    const colors = {
        light: {
            bg: '#ffffff',
            text: '#31333f',
            border: '#e0e0e0',
            primary: '#ff4b4b',
            secondary: '#f0f2f6',
            hover: '#e63946'
        },
        dark: {
            bg: '#0e1117',
            text: '#fafafa',
            border: '#4f4f4f',
            primary: '#ff6b6b',
            secondary: '#262730',
            hover: '#ff8787'
        }
    };

    const theme = isDark ? colors.dark : colors.light;
    document.body.style.fontFamily = '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif';
    document.body.style.backgroundColor = theme.bg;
    document.body.style.color = theme.text;

    const headings = document.querySelectorAll('h1');
    headings.forEach(h => {
        h.style.color = theme.text;
        h.style.fontWeight = '600';
        h.style.marginBottom = '1rem';
    });

    const labels = document.querySelectorAll('label');
    labels.forEach(label => {
        label.style.color = theme.text;
        label.style.fontWeight = '500';
        label.style.marginBottom = '0.5rem';
        label.style.display = 'inline-block';
        label.style.minWidth = '220px';
    });

    const inputs = document.querySelectorAll('input[type="file"], input[type="number"], input[type="text"]');
    inputs.forEach(input => {
        input.style.backgroundColor = theme.secondary;
        input.style.border = `1px solid ${theme.border}`;
        input.style.borderRadius = '0.25rem';
        input.style.color = theme.text;
        input.style.padding = '0.5rem';
        input.style.marginBottom = '1rem';
        input.style.width = '100%';
        input.style.maxWidth = '400px';
        input.style.fontFamily = 'inherit';
    });

    const buttons = document.querySelectorAll('button');
    buttons.forEach(button => {
        button.style.backgroundColor = theme.primary;
        button.style.color = 'white';
        button.style.border = 'none';
        button.style.borderRadius = '0.25rem';
        button.style.padding = '0.5rem 1rem';
        button.style.cursor = 'pointer';
        button.style.fontWeight = '500';
        button.style.fontFamily = 'inherit';
        button.style.transition = 'background-color 0.2s';

        button.onmouseover = () => button.style.backgroundColor = theme.hover;
        button.onmouseout = () => button.style.backgroundColor = theme.primary;
    });

    const groups = document.querySelectorAll('.group');
    groups.forEach(group => {
        group.style.border = `1px solid ${theme.border}`;
        group.style.padding = '1rem';
        group.style.borderRadius = '0.5rem';
        group.style.margin = '1rem 0';
        group.style.backgroundColor = theme.secondary;
    });

    const mapElement = document.getElementById('map');
    if (mapElement) {
        mapElement.style.border = `1px solid ${theme.border}`;
        mapElement.style.borderRadius = '0.5rem';
        mapElement.style.margin = '1rem 0';
    }

    const smallButtons = document.querySelectorAll('button.small');
    smallButtons.forEach(button => {
        button.style.padding = '2px 8px';
        button.style.marginLeft = '8px';
        button.style.fontSize = '0.875rem';
    });

    const badges = document.querySelectorAll('.badge');
    badges.forEach(badge => {
        badge.style.display = 'inline-block';
        badge.style.padding = '2px 8px';
        badge.style.borderRadius = '10px';
        badge.style.background = '#eef';
        badge.style.margin = '2px 4px 2px 0';
    });
}

applyStreamlitStyles();
if (window.matchMedia) {
    window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', applyStreamlitStyles);
}
	</script>
</body>
</html>


