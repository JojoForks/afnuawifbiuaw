<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>–ü—Ä–∏–º–∞–≥–Ω–∏—á–∏–≤–∞–Ω–∏–µ –ø–æ–ª–∏–≥–æ–Ω–æ–≤</title>
    
    <link rel="stylesheet" href="styles.css">
    <!-- Leaflet CSS -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY=" crossorigin="" />
    <!-- Leaflet-Geoman CSS -->
    <link rel="stylesheet" href="https://unpkg.com/@geoman-io/leaflet-geoman-free@latest/dist/leaflet-geoman.css" />

    <style>
        /* –°–ø–µ—Ü–∏—Ñ–∏—á–Ω—ã–µ —Å—Ç–∏–ª–∏ –¥–ª—è magnetize_polygons */
        body {
            display: flex;
            flex-direction: column;
            height: 100vh;
        }

        .header-controls {
            display: flex;
            gap: 0.75rem;
            align-items: center;
        }

        #polygon-list {
            flex: 1;
            overflow-y: auto;
            list-style: none;
            padding: 0;
            margin: 0;
        }

        .polygon-item {
            display: flex;
            align-items: center;
            padding: 10px 15px;
            border-bottom: 1px solid var(--border-color);
            cursor: pointer;
            transition: background-color 0.1s;
            gap: 10px;
        }

        .polygon-item:hover {
            background-color: var(--bg-tertiary);
        }

        .polygon-item.active {
            background-color: rgba(255, 75, 75, 0.1);
            border-left: 4px solid var(--accent-color);
            padding-left: 11px;
        }

        .polygon-color {
            width: 14px;
            height: 14px;
            border-radius: 50%;
            flex-shrink: 0;
            border: 1px solid rgba(0,0,0,0.1);
        }

        .polygon-name {
            flex: 1;
            font-size: 0.9rem;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .polygon-actions {
            display: flex;
            gap: 5px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .polygon-item:hover .polygon-actions {
            opacity: 1;
        }

        .action-icon {
            padding: 4px 6px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.9rem;
            background: none;
            border: none;
        }

        .action-icon:hover {
            background-color: rgba(255, 75, 75, 0.2);
        }

        .snap-controls {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .snap-slider-row {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .snap-slider-row input[type="range"] {
            flex: 1;
        }

        .snap-value {
            min-width: 50px;
            text-align: right;
            font-weight: 600;
            color: var(--accent-color);
            font-size: 0.9rem;
        }

        #preview-actions {
            animation: fadeIn 0.2s ease;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(-5px); }
            to { opacity: 1; transform: translateY(0); }
        }

        #map-container {
            flex: 1;
            display: flex;
            flex-direction: column;
            position: relative;
        }

        #map {
            flex: 1;
            z-index: 1;
        }

        .leaflet-bottom.leaflet-right {
            display: none !important;
        }

        #status {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 10px 20px;
            border-radius: 30px;
            font-size: 0.9rem;
            opacity: 0;
            transition: opacity 0.3s;
            pointer-events: none;
            z-index: 2000;
        }

        .empty-state {
            padding: 30px 20px;
            text-align: center;
            color: var(--text-muted);
        }

        .loading-overlay {
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(255,255,255,0.8);
            z-index: 3000;
            display: none;
            justify-content: center;
            align-items: center;
            flex-direction: column;
        }

        @media (prefers-color-scheme: dark) {
            .loading-overlay {
                background: rgba(14, 17, 23, 0.9);
            }
        }
    </style>
</head>
<body>

    <header class="app-header">
        <div class="header-left">
            <h1>–ü—Ä–∏–º–∞–≥–Ω–∏—á–∏–≤–∞–Ω–∏–µ –ø–æ–ª–∏–≥–æ–Ω–æ–≤<span class="info-icon" data-tooltip="–£–±–∏—Ä–∞–µ—Ç –¥—ã—Ä–∫–∏ –∏ –Ω–∞–ª–æ–∂–µ–Ω–∏—è –º–µ–∂–¥—É –∑–æ–Ω–∞–º–∏, –¥–µ–ª–∞—è –∏—Ö –≥—Ä–∞–Ω–∏—Ü—ã –≤ —É–ø–æ—Ä –∫ –¥—Ä—É–≥ –¥—Ä—É–≥—É.">‚ÑπÔ∏è</span></h1>
        </div>
        <div class="controls">
            <div class="input-group">
                <input type="text" id="url-input" class="url-input" placeholder="UUID –∏–ª–∏ —Å—Å—ã–ª–∫–∞ –Ω–∞ –ø–ª–∞–Ω–∏—Ä–æ–≤–∞–Ω–∏–µ">
                <button onclick="loadFromUrl()" class="btn btn-load">–ó–∞–≥—Ä—É–∑–∏—Ç—å</button>
            </div>
            
            <div class="divider"></div>

            <input type="file" id="file-input" accept=".json,.geojson">
            
            <button onclick="exportGeoJSON()" class="btn btn-primary">üíæ –°–æ—Ö—Ä–∞–Ω–∏—Ç—å</button>
        </div>
    </header>

    <div class="main-container">
        <aside class="sidebar" id="sidebar">
            <div class="sidebar-section">
                <button id="create-polygon-btn" class="btn btn-success" style="width: 100%;">+ –°–æ–∑–¥–∞—Ç—å –ø–æ–ª–∏–≥–æ–Ω</button>
            </div>

            <div class="sidebar-section snap-controls">
                <h3>–î–∏—Å—Ç–∞–Ω—Ü–∏—è (–º)</h3>
                <div class="snap-slider-row">
                    <input type="range" id="snap-distance-slider" min="0" max="5000" step="50" value="1500">
                    <span class="snap-value" id="snap-distance-value">1500</span>
                </div>
                <div id="preview-actions" style="display: none; margin-top: 10px;">
                    <div style="display: flex; gap: 8px;">
                        <button id="apply-preview-btn" class="btn btn-success" style="flex: 1; padding: 6px;">‚úì –ü—Ä–∏–º–µ–Ω–∏—Ç—å</button>
                        <button id="cancel-preview-btn" class="btn btn-cancel" style="flex: 1; padding: 6px;">‚úï –û—Ç–º–µ–Ω–∏—Ç—å</button>
                    </div>
                    <div id="preview-status" style="font-size: 0.8rem; color: #f59e0b; margin-top: 6px; text-align: center;">–ü—Ä–µ–¥–ø—Ä–æ—Å–º–æ—Ç—Ä</div>
                </div>
            </div>

            <div class="sidebar-section" style="padding-bottom: 8px;">
                <div style="display: flex; justify-content: space-between; align-items: center;">
                    <h3 style="margin: 0;">–ü–æ–ª–∏–≥–æ–Ω—ã</h3>
                    <span id="polygon-count" style="color: #9ca3af; font-size: 0.85rem;">0</span>
                </div>
            </div>

            <ul id="polygon-list">
                <li class="empty-state">–ù–µ—Ç –ø–æ–ª–∏–≥–æ–Ω–æ–≤</li>
            </ul>
        </aside>

        <div id="map-container">
            <div id="map"></div>
            <div id="status"></div>
        </div>
    </div>

    <div id="loading-overlay" class="loading-overlay">
        <div class="spinner"></div>
        <div style="margin-top: 10px; font-weight: 600;">–ó–∞–≥—Ä—É–∑–∫–∞...</div>
    </div>

    <!-- Leaflet JS -->
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo=" crossorigin=""></script>
    <!-- Leaflet-Geoman JS -->
    <script src="https://unpkg.com/@geoman-io/leaflet-geoman-free@latest/dist/leaflet-geoman.min.js"></script>
    <!-- Turf.js -->
    <script src="https://cdn.jsdelivr.net/npm/@turf/turf@6/turf.min.js"></script>

<script>
// --- Init Map ---
const map = L.map('map').setView([55.76, 37.64], 10);

L.tileLayer('https://tiles.api-maps.yandex.ru/v1/tiles/?apikey=567685cf-50f2-407c-9545-c91fd8b9c384&lang=ru_RU&x={x}&y={y}&z={z}&l=map&projection=web_mercator', {
    attribution: '&copy; –Ø–Ω–¥–µ–∫—Å –ö–∞—Ä—Ç—ã',
    maxZoom: 20
}).addTo(map);

// Geoman controls
map.pm.addControls({
    position: 'topleft',
    drawCircle: false,
    drawCircleMarker: false,
    drawMarker: false,
    drawPolyline: false,
    drawRectangle: true,
    drawPolygon: true,
    editMode: true,
    dragMode: true,
    cutPolygon: false,
    removalMode: true,
});

map.pm.setLang('ru');

// --- State ---
let polygons = []; // { id, name, color, layer }
let polygonIdCounter = 1;
let maxSnapDistance = 1500;
let isPreviewing = false;
let previewCoordinates = [];
let previewDebounceTimer = null;

const COLORS = ['#ef4444', '#f97316', '#f59e0b', '#84cc16', '#10b981', '#06b6d4', '#3b82f6', '#6366f1', '#8b5cf6', '#d946ef', '#f43f5e'];

function getColor(index) {
    return COLORS[index % COLORS.length];
}

// --- Events ---
document.getElementById('file-input').addEventListener('change', loadFile);
document.getElementById('apply-preview-btn').addEventListener('click', applyPreview);
document.getElementById('cancel-preview-btn').addEventListener('click', cancelPreview);
document.getElementById('create-polygon-btn').addEventListener('click', () => {
    map.pm.enableDraw('Polygon', { snappable: true, snapDistance: 20 });
    showStatus('–ö–ª–∏–∫–∞–π—Ç–µ –¥–ª—è –¥–æ–±–∞–≤–ª–µ–Ω–∏—è —Ç–æ—á–µ–∫. –î–≤–æ–π–Ω–æ–π –∫–ª–∏–∫ ‚Äî –∑–∞–≤–µ—Ä—à–∏—Ç—å.');
});

const snapSlider = document.getElementById('snap-distance-slider');
snapSlider.addEventListener('input', function() {
    const val = parseInt(this.value);
    document.getElementById('snap-distance-value').textContent = val;
    maxSnapDistance = val;
    
    if (polygons.length > 0) {
        clearTimeout(previewDebounceTimer);
        previewDebounceTimer = setTimeout(runPreview, 300);
    }
});

// New polygon created
map.on('pm:create', e => {
    const layer = e.layer;
    if (e.shape === 'Polygon' || e.shape === 'Rectangle') {
        const name = `–ü–æ–ª–∏–≥–æ–Ω ${polygonIdCounter}`;
        const color = getColor(polygonIdCounter - 1);
        
        layer.setStyle({ color: color, fillColor: color, fillOpacity: 0.3, weight: 2 });
        
        const poly = {
            id: polygonIdCounter++,
            name: name,
            color: color,
            layer: layer
        };
        
        polygons.push(poly);
        addToList(poly);
        updateCount();
        
        layer.on('click', () => selectPolygon(poly));
        layer.bindTooltip(name);
        
        showStatus('–ü–æ–ª–∏–≥–æ–Ω —Å–æ–∑–¥–∞–Ω');
    }
});

// Polygon removed via Geoman
map.on('pm:remove', e => {
    const layer = e.layer;
    const poly = polygons.find(p => p.layer === layer);
    if (poly) {
        polygons = polygons.filter(p => p.id !== poly.id);
        removeFromList(poly.id);
        updateCount();
        showStatus('–ü–æ–ª–∏–≥–æ–Ω —É–¥–∞–ª—ë–Ω');
    }
});

// --- URL Loading ---
async function loadFromUrl() {
    const input = document.getElementById('url-input').value.trim();
    if (!input) return alert('–í–≤–µ–¥–∏—Ç–µ —Å—Å—ã–ª–∫—É –∏–ª–∏ UUID');

    const uuidMatch = input.match(/([a-f0-9]+-[a-f0-9]+-[a-f0-9]+-[a-f0-9]+)/i);
    if (!uuidMatch) return alert('–ù–µ —É–¥–∞–ª–æ—Å—å –Ω–∞–π—Ç–∏ UUID');

    const uuid = uuidMatch[0];
    setLoading(true);
    showStatus(`–ó–∞–≥—Ä—É–∑–∫–∞: ${uuid}...`);

    try {
        const response = await fetch(`https://routeq.gens.codes/request/${uuid}`);
        if (!response.ok) throw new Error(`–û—à–∏–±–∫–∞: ${response.status}`);
        const data = await response.json();
        
        let geojson;
        if (data.zones && Array.isArray(data.zones)) {
            geojson = {
                type: 'FeatureCollection',
                features: data.zones.map(z => ({
                    type: 'Feature',
                    geometry: z.geometry,
                    properties: { name: z.id }
                }))
            };
        } else if (data.features) {
            geojson = data;
        } else {
            throw new Error('–ù–µ–ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ–º—ã–π —Ñ–æ—Ä–º–∞—Ç');
        }
        
        loadGeoJSON(geojson);
        showStatus('–ó–∞–≥—Ä—É–∂–µ–Ω–æ');
    } catch (err) {
        alert(`–û—à–∏–±–∫–∞: ${err.message}`);
    } finally {
        setLoading(false);
    }
}

// --- File Loading ---
function loadFile(e) {
    const file = e.target.files[0];
    if (!file) return;

    setLoading(true);
    const reader = new FileReader();
    reader.onload = function(e) {
        try {
            const data = JSON.parse(e.target.result);
            let geojson;
            
            if (data.zones && Array.isArray(data.zones)) {
                geojson = {
                    type: 'FeatureCollection',
                    features: data.zones.map(z => ({
                        type: 'Feature',
                        geometry: z.geometry,
                        properties: { name: z.id }
                    }))
                };
            } else if (data.features) {
                geojson = data;
            } else {
                throw new Error('–ù–µ–ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ–º—ã–π —Ñ–æ—Ä–º–∞—Ç');
            }
            
            loadGeoJSON(geojson);
            showStatus('–§–∞–π–ª –∑–∞–≥—Ä—É–∂–µ–Ω');
        } catch (err) {
            alert('–û—à–∏–±–∫–∞: ' + err.message);
        } finally {
            setLoading(false);
            e.target.value = '';
        }
    };
    reader.readAsText(file);
}

function loadGeoJSON(geojson) {
    // Clear existing
    polygons.forEach(p => map.removeLayer(p.layer));
    polygons = [];
    polygonIdCounter = 1;
    document.getElementById('polygon-list').innerHTML = '';

    const bounds = L.latLngBounds();

    geojson.features.forEach((feature, idx) => {
        if (feature.geometry.type !== 'Polygon' && feature.geometry.type !== 'MultiPolygon') return;

        const color = getColor(idx);
        const name = feature.properties?.name || feature.properties?.description || feature.properties?.id || `–ü–æ–ª–∏–≥–æ–Ω ${polygonIdCounter}`;

        const layer = L.geoJSON(feature, {
            style: { color: color, fillColor: color, fillOpacity: 0.3, weight: 2 }
        });

        layer.eachLayer(l => {
            l.addTo(map);
            bounds.extend(l.getBounds());

            const poly = {
                id: polygonIdCounter++,
                name: name,
                color: color,
                layer: l
            };

            polygons.push(poly);
            addToList(poly);

            l.on('click', () => selectPolygon(poly));
            l.bindTooltip(name);
        });
    });

    if (polygons.length > 0) {
        map.fitBounds(bounds.pad(0.1));
    }

    updateCount();
}

// --- Sidebar ---
function addToList(poly) {
    const list = document.getElementById('polygon-list');
    const empty = list.querySelector('.empty-state');
    if (empty) empty.remove();

    const li = document.createElement('li');
    li.className = 'polygon-item';
    li.dataset.id = poly.id;

    li.innerHTML = `
        <div class="polygon-color" style="background-color: ${poly.color}"></div>
        <div class="polygon-name">
            <input type="text" value="${poly.name}" />
        </div>
        <div class="polygon-actions">
            <button class="action-icon" title="–£–¥–∞–ª–∏—Ç—å">üóëÔ∏è</button>
        </div>
    `;

    const input = li.querySelector('input');
    input.addEventListener('change', () => {
        poly.name = input.value;
        poly.layer.unbindTooltip();
        poly.layer.bindTooltip(input.value);
    });
    input.addEventListener('click', e => e.stopPropagation());

    li.querySelector('.action-icon').addEventListener('click', e => {
        e.stopPropagation();
        if (confirm(`–£–¥–∞–ª–∏—Ç—å ${poly.name}?`)) {
            map.removeLayer(poly.layer);
            polygons = polygons.filter(p => p.id !== poly.id);
            removeFromList(poly.id);
            updateCount();
            showStatus('–£–¥–∞–ª–µ–Ω–æ');
        }
    });

    li.addEventListener('click', () => selectPolygon(poly));

    list.appendChild(li);
}

function removeFromList(id) {
    const li = document.querySelector(`[data-id="${id}"]`);
    if (li) li.remove();
    
    if (polygons.length === 0) {
        document.getElementById('polygon-list').innerHTML = '<li class="empty-state">–ù–µ—Ç –ø–æ–ª–∏–≥–æ–Ω–æ–≤</li>';
    }
}

function selectPolygon(poly) {
    document.querySelectorAll('.polygon-item').forEach(el => el.classList.remove('active'));
    const li = document.querySelector(`[data-id="${poly.id}"]`);
    if (li) li.classList.add('active');

    map.fitBounds(poly.layer.getBounds(), { padding: [50, 50] });
    
    // Enable edit
    map.pm.disableGlobalEditMode();
    polygons.forEach(p => { if (p.layer.pm) p.layer.pm.disable(); });
    if (poly.layer.pm) poly.layer.pm.enable();
}

function updateCount() {
    document.getElementById('polygon-count').textContent = polygons.length;
}

// --- Preview ---
function savePreviewCoordinates() {
    previewCoordinates = polygons.map(p => ({
        id: p.id,
        coords: p.layer.toGeoJSON().geometry.coordinates
    }));
}

function restorePreviewCoordinates() {
    previewCoordinates.forEach(saved => {
        const poly = polygons.find(p => p.id === saved.id);
        if (poly && poly.layer) {
            const feature = { type: 'Feature', geometry: { type: 'Polygon', coordinates: saved.coords } };
            const newLatLngs = L.GeoJSON.coordsToLatLngs(saved.coords, 1);
            poly.layer.setLatLngs(newLatLngs);
        }
    });
}

function runPreview() {
    if (polygons.length === 0) return;

    if (!isPreviewing) {
        savePreviewCoordinates();
        isPreviewing = true;
    } else {
        restorePreviewCoordinates();
    }

    document.getElementById('preview-actions').style.display = 'block';
    showStatus('–ü—Ä–µ–¥–ø—Ä–æ—Å–º–æ—Ç—Ä...');

    setTimeout(() => {
        snapVertices();
        showStatus(`–ü—Ä–µ–¥–ø—Ä–æ—Å–º–æ—Ç—Ä: ${maxSnapDistance}–º`);
    }, 10);
}

function applyPreview() {
    if (!isPreviewing) return;

    showStatus('–ü—Ä–∏–º–µ–Ω–µ–Ω–∏–µ...');
    
    // Full processing
    densifyEdges();
    trimPolygons();
    fillGaps();

    isPreviewing = false;
    previewCoordinates = [];
    document.getElementById('preview-actions').style.display = 'none';
    showStatus('–ü—Ä–∏–º–µ–Ω–µ–Ω–æ');
}

function cancelPreview() {
    if (!isPreviewing) return;

    restorePreviewCoordinates();
    isPreviewing = false;
    previewCoordinates = [];
    document.getElementById('preview-actions').style.display = 'none';
    showStatus('–û—Ç–º–µ–Ω–µ–Ω–æ');
}

// --- Snap Logic ---
function snapVertices() {
    const features = polygons.map(p => p.layer.toGeoJSON());

    for (let i = 0; i < features.length; i++) {
        const coords = features[i].geometry.coordinates[0];

        for (let vi = 0; vi < coords.length - 1; vi++) {
            const vertex = coords[vi];
            let bestDist = Infinity;
            let bestPoint = null;

            for (let j = 0; j < features.length; j++) {
                if (i === j) continue;
                const otherCoords = features[j].geometry.coordinates[0];

                for (let k = 0; k < otherCoords.length - 1; k++) {
                    const proj = projectPointToSegment(vertex, otherCoords[k], otherCoords[k + 1]);
                    if (proj.dist < bestDist) {
                        bestDist = proj.dist;
                        bestPoint = proj.point;
                    }
                }
            }

            if (bestPoint && bestDist <= maxSnapDistance) {
                coords[vi] = bestPoint;
            }
        }

        // Close ring
        coords[coords.length - 1] = coords[0];

        // Update layer
        const newLatLngs = L.GeoJSON.coordsToLatLngs([coords], 1);
        polygons[i].layer.setLatLngs(newLatLngs);
    }
}

function densifyEdges() {
    const features = polygons.map(p => p.layer.toGeoJSON());

    for (let i = 0; i < features.length; i++) {
        let coords = features[i].geometry.coordinates[0].slice();
        let modified = false;

        for (let j = 0; j < features.length; j++) {
            if (i === j) continue;
            const otherCoords = features[j].geometry.coordinates[0];

            for (let v = 0; v < otherCoords.length - 1; v++) {
                const vertex = otherCoords[v];

                for (let k = 0; k < coords.length - 1; k++) {
                    const proj = projectPointToSegment(vertex, coords[k], coords[k + 1]);
                    if (proj.dist <= maxSnapDistance && proj.dist > 0.1) {
                        // Check not too close to existing points
                        const d1 = turf.distance(turf.point(proj.point), turf.point(coords[k]), { units: 'meters' });
                        const d2 = turf.distance(turf.point(proj.point), turf.point(coords[k + 1]), { units: 'meters' });
                        if (d1 > 1 && d2 > 1) {
                            coords.splice(k + 1, 0, proj.point);
                            modified = true;
                            break;
                        }
                    }
                }
            }
        }

        if (modified) {
            coords[coords.length - 1] = coords[0];
            const newLatLngs = L.GeoJSON.coordsToLatLngs([coords], 1);
            polygons[i].layer.setLatLngs(newLatLngs);
        }
    }
}

function trimPolygons() {
    const sorted = polygons.slice().sort((a, b) => a.id - b.id);

    for (let i = 1; i < sorted.length; i++) {
        let current = sorted[i].layer.toGeoJSON();
        let union = null;

        for (let j = 0; j < i; j++) {
            const prev = sorted[j].layer.toGeoJSON();
            union = union ? turf.union(union, prev) : prev;
        }

        if (union) {
            try {
                const diff = turf.difference(current, union);
                if (diff && diff.geometry.type === 'Polygon') {
                    const newLatLngs = L.GeoJSON.coordsToLatLngs(diff.geometry.coordinates, 1);
                    sorted[i].layer.setLatLngs(newLatLngs);
                } else if (diff && diff.geometry.type === 'MultiPolygon') {
                    // Take largest
                    let best = null, bestArea = 0;
                    diff.geometry.coordinates.forEach(c => {
                        const a = turf.area({ type: 'Feature', geometry: { type: 'Polygon', coordinates: c } });
                        if (a > bestArea) { bestArea = a; best = c; }
                    });
                    if (best) {
                        const newLatLngs = L.GeoJSON.coordsToLatLngs(best, 1);
                        sorted[i].layer.setLatLngs(newLatLngs);
                    }
                }
            } catch (e) {}
        }
    }
}

function fillGaps() {
    if (polygons.length < 2) return;

    const features = polygons.map(p => p.layer.toGeoJSON());
    let union = features[0];
    for (let i = 1; i < features.length; i++) {
        union = turf.union(union, features[i]);
    }

    try {
        const inflated = turf.buffer(union, maxSnapDistance, { units: 'meters' });
        const deflated = turf.buffer(inflated, -maxSnapDistance, { units: 'meters' });
        if (!deflated) return;

        const gaps = turf.difference(deflated, union);
        if (!gaps) return;

        const gapList = gaps.geometry.type === 'Polygon' 
            ? [gaps] 
            : gaps.geometry.coordinates.map(c => ({ type: 'Feature', geometry: { type: 'Polygon', coordinates: c } }));

        gapList.forEach(gap => {
            const centroid = turf.centroid(gap);
            let bestIdx = -1, bestDist = Infinity;

            features.forEach((f, idx) => {
                const line = turf.polygonToLine(f);
                const d = turf.pointToLineDistance(centroid, line, { units: 'meters' });
                if (d < bestDist) { bestDist = d; bestIdx = idx; }
            });

            if (bestIdx >= 0) {
                try {
                    const merged = turf.union(features[bestIdx], gap);
                    if (merged && merged.geometry.type === 'Polygon') {
                        features[bestIdx] = merged;
                        const newLatLngs = L.GeoJSON.coordsToLatLngs(merged.geometry.coordinates, 1);
                        polygons[bestIdx].layer.setLatLngs(newLatLngs);
                    }
                } catch (e) {}
            }
        });
    } catch (e) {}
}

function projectPointToSegment(p, a, b) {
    try {
        const line = turf.lineString([a, b]);
        const pt = turf.point(p);
        const nearest = turf.nearestPointOnLine(line, pt);
        const dist = turf.distance(pt, nearest, { units: 'meters' });
        return { point: nearest.geometry.coordinates, dist: dist };
    } catch (e) {
        return { point: p, dist: Infinity };
    }
}

// --- Export ---
function exportGeoJSON() {
    if (polygons.length === 0) {
        showStatus('–ù–µ—Ç –ø–æ–ª–∏–≥–æ–Ω–æ–≤');
        return;
    }

    const features = polygons.map(p => {
        const geo = p.layer.toGeoJSON();
        geo.properties = { description: p.name };
        return geo;
    });

    const geojson = { type: 'FeatureCollection', features: features };
    const blob = new Blob([JSON.stringify(geojson, null, 2)], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = 'polygons.geojson';
    a.click();
    URL.revokeObjectURL(url);
    showStatus('–°–æ—Ö—Ä–∞–Ω–µ–Ω–æ');
}

// --- Utils ---
function showStatus(msg) {
    const el = document.getElementById('status');
    el.textContent = msg;
    el.style.opacity = 1;
    setTimeout(() => el.style.opacity = 0, 3000);
}

function setLoading(show) {
    document.getElementById('loading-overlay').style.display = show ? 'flex' : 'none';
}
</script>

</body>
</html>
